# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'featurebinningproperties.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from typing import Optional
from gui.widgets.py_line_edit.py_line_edit import PyLineEdit
from gui.widgets.py_tree_view.py_tree_view import PyTreeView
from qt_core import *


feature_binning_properties_default_input = {}


class Ui_FeatureBinningProperties(QObject):
    def __init__(self, parent: Optional[QObject], theme: dict) -> None:
        super().__init__(parent)
        self.theme = theme

    def setupUi(self, Dialog):
        Dialog.setObjectName("Feature Binning Properties")
        Dialog.resize(900, 600)
        self.horizontalLayout = QHBoxLayout(Dialog)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.lineEdit = PyLineEdit(
            text = "",
            place_holder_text = "Type to search",
            radius = 8,
            border_size = 2,
            color = self.theme["text_foreground"],
            selection_color = self.theme["white"],
            bg_color = self.theme["dark_one"],
            bg_color_active = self.theme["dark_three"],
            context_color = self.theme["context_color"]
        )

        @Slot(str)
        def onTextChanged(text: str):
            self.setFilterText(text)
        self.lineEdit.textChanged.connect(onTextChanged)

        self.lineEdit.setObjectName("lineEdit")
        self.verticalLayout.addWidget(self.lineEdit)
        self.treeView = PyTreeView(
            radius = 8,
            color = self.theme["text_foreground"],
            selection_color = self.theme["bg_one"],
            bg_color = self.theme["bg_two"],
            scroll_bar_bg_color = self.theme["bg_one"],
            scroll_bar_btn_color = self.theme["dark_four"],
            context_color = self.theme["context_color"]
        )
        self.treeView.setObjectName("treeView")

        self.treeView.setHeaderHidden(True)
        self.treeView.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.treeView.setDragEnabled(False)
        self.treeView.setAcceptDrops(False)
        self.treeView.setDropIndicatorShown(False)
        self.treeView.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.treeView.setContextMenuPolicy(Qt.CustomContextMenu)

        # self.treeView.clicked.connect(self.selection_changed)
        # self.treeView.customContextMenuRequested.connect(self.open_menu)

        self.verticalLayout.addWidget(self.treeView)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.listView = QListView(Dialog)
        self.listView.setObjectName("listView")
        self.horizontalLayout.addWidget(self.listView)
        self.horizontalLayout.setStretch(0, 1)
        self.horizontalLayout.setStretch(2, 1)

        self.retranslateUi(Dialog)
        QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
    
    def setFilterText(self, text):
        if self.proxyModel is not None:
            self.proxyModel.setFilterRegularExpression(text)

    def setInput(self, input):
        self.input = input
    
    def getOutput(self):
        return self.input
    
    def setObjectHierarchy(self, hierarchy: dict):
        self.model = QStandardItemModel()
        self.proxyModel = QSortFilterProxyModel()
        self.proxyModel.setRecursiveFilteringEnabled(True)
        self.proxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxyModel.setSourceModel(self.model)
        self.treeView.setModel(self.proxyModel)

        for name, type in hierarchy["types"].items():
            if type == "Region":
                item = QStandardItem(name)
                self.model.appendRow(item)
                self.populateChildren(item, name, hierarchy)
    
    def populateChildren(self, item: QStandardItem, name: str, hierarchy: dict):
        if name in hierarchy["children"]:
            for child in hierarchy["children"][name]:
                parent_item = item
                
                if hierarchy["types"][child] == "Group":
                    continue

                if hierarchy["types"][child] not in ["Region", "Zone", "Node"]:
                    parent_item = self.getOrCreateItem(item, hierarchy["types"][child])

                new_item = QStandardItem(child)
                parent_item.appendRow(new_item)
                self.populateChildren(new_item, child, hierarchy)
    
    def getOrCreateItem(self, item: QStandardItem, name: str):
        for i in range(item.rowCount()):
            ix = self.model.index(i, 0, item.index())
            if ix.data(Qt.DisplayRole) == name:
                return self.model.itemFromIndex(ix)
        
        new_item = QStandardItem(name)
        item.appendRow(new_item)
        return new_item
