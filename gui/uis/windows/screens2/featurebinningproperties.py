# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'featurebinningproperties.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from typing import Optional
from gui.widgets.py_line_edit.py_line_edit import PyLineEdit
from gui.widgets.py_tree_view.py_tree_view import PyTreeView
from qt_core import *


feature_binning_properties_default_input = {}


class Ui_FeatureBinningProperties(QObject):
    def __init__(self, parent: Optional[QObject], theme: dict) -> None:
        super().__init__(parent)
        self.theme = theme
        self.currentSelection = None

    def setupUi(self, Dialog):
        Dialog.setObjectName("Feature Binning Properties")
        Dialog.resize(900, 600)
        self.horizontalLayout = QHBoxLayout(Dialog)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.lineEdit = PyLineEdit(
            text = "",
            place_holder_text = "Type to search",
            radius = 8,
            border_size = 2,
            color = self.theme["text_foreground"],
            selection_color = self.theme["white"],
            bg_color = self.theme["dark_one"],
            bg_color_active = self.theme["dark_three"],
            context_color = self.theme["context_color"]
        )

        @Slot(str)
        def onTextChanged(text: str):
            self.setFilterText(text)
        self.lineEdit.textChanged.connect(onTextChanged)

        self.lineEdit.setObjectName("lineEdit")
        self.verticalLayout.addWidget(self.lineEdit)
        self.treeView = PyTreeView(
            radius = 8,
            color = self.theme["text_foreground"],
            selection_color = self.theme["bg_one"],
            bg_color = self.theme["bg_two"],
            scroll_bar_bg_color = self.theme["bg_one"],
            scroll_bar_btn_color = self.theme["dark_four"],
            context_color = self.theme["context_color"]
        )
        self.treeView.setObjectName("treeView")

        self.treeView.setHeaderHidden(True)
        self.treeView.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.treeView.setDragEnabled(False)
        self.treeView.setAcceptDrops(False)
        self.treeView.setDropIndicatorShown(False)
        self.treeView.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.treeView.setContextMenuPolicy(Qt.CustomContextMenu)
        self.treeView.clicked.connect(self.selectionChanged)

        self.verticalLayout.addWidget(self.treeView)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.tableWidget = QTableWidget(Dialog)
        self.tableWidget.setObjectName("tableWidget")

        self.tableWidget.setColumnCount(3)
        self.tableWidget.setRowCount(0)
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget.setSelectionMode(QAbstractItemView.SingleSelection)
        self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.tableWidget.verticalHeader().setVisible(False)
        
        self.column_1 = QTableWidgetItem()
        self.column_1.setTextAlignment(Qt.AlignCenter)
        self.column_1.setText("Enabled?")
        self.tableWidget.setHorizontalHeaderItem(0, self.column_1)
        self.tableWidget.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)

        self.column_2 = QTableWidgetItem()
        self.column_2.setTextAlignment(Qt.AlignCenter)
        self.column_2.setText("Property")
        self.tableWidget.setHorizontalHeaderItem(1, self.column_2)
        self.tableWidget.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)

        self.column_3 = QTableWidgetItem()
        self.column_3.setTextAlignment(Qt.AlignCenter)
        self.column_3.setText("Group")
        self.tableWidget.setHorizontalHeaderItem(2, self.column_3)
        self.tableWidget.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)

        self.horizontalLayout.addWidget(self.tableWidget)
        self.horizontalLayout.setStretch(0, 1)
        self.horizontalLayout.setStretch(1, 1)

        self.retranslateUi(Dialog)
        QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
    
    def setFilterText(self, text):
        if self.proxyModel is not None:
            self.proxyModel.setFilterRegularExpression(text)

    def setInput(self, input):
        self.input = input
    
    def getOutput(self):
        self.saveFeatures()
        return self.input
    
    def setObjectHierarchy(self, hierarchy: dict):
        self.model = QStandardItemModel()
        self.proxyModel = QSortFilterProxyModel()
        self.proxyModel.setRecursiveFilteringEnabled(True)
        self.proxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxyModel.setSourceModel(self.model)
        self.treeView.setModel(self.proxyModel)
        self.currentSelection = None

        for name, type in hierarchy["types"].items():
            if type == "Region":
                item = QStandardItem(name)
                item.setData("Region", Qt.UserRole)
                self.model.appendRow(item)
                self.populateChildren(item, name, hierarchy)
    
    def setObjectProperties(self, properties: dict):
        self.objectProperties = properties
    
    def populateChildren(self, item: QStandardItem, name: str, hierarchy: dict):
        if name in hierarchy["children"]:
            for child in hierarchy["children"][name]:
                parent_item = item
                
                if hierarchy["types"][child] == "Group":
                    continue

                if hierarchy["types"][child] not in ["Region", "Zone", "Node"]:
                    parent_item = self.getOrCreateItem(item, hierarchy["types"][child])

                new_item = QStandardItem(child)
                new_item.setData(hierarchy["types"][child], Qt.UserRole)
                parent_item.appendRow(new_item)
                self.populateChildren(new_item, child, hierarchy)
    
    def getOrCreateItem(self, item: QStandardItem, name: str):
        for i in range(item.rowCount()):
            ix = self.model.index(i, 0, item.index())
            if ix.data(Qt.DisplayRole) == name:
                return self.model.itemFromIndex(ix)
        
        new_item = QStandardItem(name)
        item.appendRow(new_item)
        return new_item

    def selectionChanged(self):
        self.saveFeatures()

        selected = self.treeView.currentIndex()
        if selected is None:
            self.currentSelection = None
            return

        type = selected.data(Qt.UserRole)
        self.currentSelection = selected.data(Qt.DisplayRole)
        
        self.clearTable()

        if type not in ["Region", "Zone", "Node", None]:
            self.addTableItems(self.objectProperties[type])

    def clearTable(self):
        self.tableWidget.setRowCount(0)

    def addTableItems(self, items):
        self.tableWidget.setRowCount(len(items))
        for i, item in enumerate(items):
            enabledCheckbox = QCheckBox()
            groupLineEdit = QLineEdit()
            if self.currentSelection in self.input:
                if item in self.input[self.currentSelection]:
                    enabledCheckbox.setChecked(self.input[self.currentSelection][item]["enabled"])
                    groupLineEdit.setText(self.input[self.currentSelection][item]["group"])

            self.tableWidget.setCellWidget(i, 0, enabledCheckbox)
            self.tableWidget.setItem(i, 1, QTableWidgetItem(item))
            self.tableWidget.setCellWidget(i, 2, groupLineEdit)

    def saveFeatures(self):
        if self.currentSelection is None:
            return

        self.input[self.currentSelection] = {}
        for i in range(self.tableWidget.rowCount()):
            enabled = self.tableWidget.cellWidget(i, 0).isChecked()
            name = self.tableWidget.item(i, 1).text()
            group = self.tableWidget.cellWidget(i, 2).text()

            self.input[self.currentSelection][name] = {
                "enabled": enabled,
                "group": group
            }
