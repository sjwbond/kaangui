# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import copy
from functools import partial
from typing import List, Optional, Union
from gui.core.create_json import get_folder
from gui.uis.custom.combo_delegate import ComboDelegate
from gui.uis.custom.model_controller import ModelController
from gui.uis.custom.text_delegate import TextDelegate
from qt_core import *


def remove_non_unique_fields_from_property(property: dict) -> dict:
    del property["Value"]
    del property["Variable"]
    del property["Variable_Effect"]
    if "Object Name" in property:
        del property["Object Name"]
    return property

def properties_roughly_equal(a: dict, b: dict) -> bool:
    a_copy = remove_non_unique_fields_from_property(a.copy())
    b_copy = remove_non_unique_fields_from_property(b.copy())
    return a_copy == b_copy

def remove_similar_properties(properties: list[dict], property: dict):
    to_remove = []
    for old_property in properties:
        if properties_roughly_equal(old_property, property):
            to_remove.append(old_property)
    for item in to_remove:
        properties.remove(item)


def remove_non_unique_fields_from_relationship(relationship: dict) -> dict:
    del relationship["Parent Property"]
    if "Object Name" in relationship:
        del relationship["Object Name"]
    return relationship

def relationships_roughly_equal(a: dict, b: dict) -> bool:
    a_copy = remove_non_unique_fields_from_relationship(a.copy())
    b_copy = remove_non_unique_fields_from_relationship(b.copy())
    return a_copy == b_copy

def remove_similar_relationships(relationships: list[dict], relationship: dict):
    to_remove = []
    for old_relationship in relationships:
        if relationships_roughly_equal(old_relationship, relationship):
            to_remove.append(old_relationship)
    for item in to_remove:
        relationships.remove(item)


class Ui_ImportObjectsDialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Import Objects")
        Dialog.resize(1200, 800)
        self.verticalLayout_2 = QVBoxLayout(Dialog)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout = QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.objectsTableView = ObjectsTableView(Dialog)
        self.objectsTableView.setObjectName("objectsTableView")
        self.verticalLayout.addWidget(self.objectsTableView)
        self.addObjectsFilePushButton = QPushButton(Dialog)
        self.addObjectsFilePushButton.setObjectName("addObjectsFilePushButton")
        self.verticalLayout.addWidget(self.addObjectsFilePushButton)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.horizontalLayout.setStretch(0, 2)
        self.verticalLayout_3 = QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.propertiesTableView = PropertiesTableView(Dialog)
        self.propertiesTableView.setObjectName("propertiesTableView")
        self.verticalLayout_3.addWidget(self.propertiesTableView)
        self.addPropertiesFilePushButton = QPushButton(Dialog)
        self.addPropertiesFilePushButton.setObjectName("addPropertiesFilePushButton")
        self.verticalLayout_3.addWidget(self.addPropertiesFilePushButton)
        self.relationshipsTableView = RelationshipsTableView(Dialog)
        self.relationshipsTableView.setObjectName("relationshipsTableView")
        self.verticalLayout_3.addWidget(self.relationshipsTableView)
        self.addRelationshipsFilePushButton = QPushButton(Dialog)
        self.addRelationshipsFilePushButton.setObjectName("addRelationshipsFilePushButton")
        self.verticalLayout_3.addWidget(self.addRelationshipsFilePushButton)
        self.horizontalLayout.addLayout(self.verticalLayout_3)
        self.horizontalLayout.setStretch(1, 3)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.buttonBox = QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(Qt.Horizontal)
        self.buttonBox.setStandardButtons(QDialogButtonBox.Cancel|QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout_2.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(partial(self.accept_dialog, Dialog))
        self.buttonBox.rejected.connect(Dialog.reject)
        QMetaObject.connectSlotsByName(Dialog)

        self.addObjectsFilePushButton.clicked.connect(self.add_objects_file)
        self.addPropertiesFilePushButton.clicked.connect(self.add_properties_file)
        self.addRelationshipsFilePushButton.clicked.connect(self.add_relationships_file)
        self.imported_objects: list[dict] = []
        self.imported_properties: list[dict] = []
        self.imported_relationships: list[dict] = []
        self.existing_objects = {}
        self.object_items = []
        self.property_items = []
        self.relationship_items = []

    def retranslateUi(self, Dialog):
        _translate = QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Import Objects", "Import Objects"))
        self.addObjectsFilePushButton.setText(_translate("Dialog", "Select Objects File"))
        self.addPropertiesFilePushButton.setText(_translate("Dialog", "Select Properties File"))
        self.addRelationshipsFilePushButton.setText(_translate("Dialog", "Select Relationships File"))

    def set_object_types(self, object_types: list[str]):
        self.objectsTableView.set_object_types(object_types)

    def set_model_controller(self, model_controller: ModelController):
        self.model_controller = model_controller

    def add_objects_file(self):
        (name, _) = QFileDialog.getOpenFileName(None, "Select Objects Text File")
        if name != '':
            with open(name, "r", encoding="utf8") as file_in:
                objects = []
                next(file_in)
                for line in file_in:
                    parts = line.rstrip('\n').split('\t')
                    objects.append({
                        "Object_Name": parts[0],
                        "Object_Type": parts[1],
                        "Subfolder": get_folder(parts[0]) or ""
                    })
                self.imported_objects = objects
                self.update_tables()

    def add_properties_file(self):
        (name, _) = QFileDialog.getOpenFileName(None, "Select Properties Text File")
        if name != '':
            with open(name, "r", encoding="utf8") as file_in:
                properties = []
                next(file_in)
                for line in file_in:
                    parts = line.rstrip('\n').split('\t')
                    properties.append({
                        "Object Name": parts[0],
                        "Parent Object": parts[1],
                        "Target Object": parts[2],
                        "Property": parts[3],
                        "Date_From": parts[4],
                        "Date_To": parts[5],
                        "Value": parts[6],
                        "Variable": parts[7],
                        "Variable_Effect": parts[8],
                        "Timeslice": parts[9],
                        "Timeslice_Index": parts[10],
                        "Group_id": parts[11],
                        "Priority": parts[12],
                        "Scenario": parts[13]
                    })
                self.imported_properties = properties
                self.update_tables()

    def add_relationships_file(self):
        (name, _) = QFileDialog.getOpenFileName(None, "Select Relationships Text File")
        if name != '':
            with open(name, "r", encoding="utf8") as file_in:
                relationships = []
                next(file_in)
                for line in file_in:
                    parts = line.rstrip('\n').split('\t')
                    relationships.append({
                        "Object Name": parts[0],
                        "Parent Object": parts[1],
                        "Parent Property": parts[2] if len(parts) > 2 else ""
                    })
                self.imported_relationships = relationships
                self.update_tables()

    def find_existing_property(self, property: dict) -> Optional[dict]:
        if property["Object Name"] in self.existing_objects:
            for old_property in self.existing_objects[property["Object Name"]].data(Qt.UserRole)["Properties"]:
                if properties_roughly_equal(old_property, property):
                    return old_property
        return None

    def find_existing_relationship(self, relationship: dict) -> Optional[dict]:
        if relationship["Parent Object"] in self.existing_objects:
            for old_relationship in self.existing_objects[relationship["Object Name"]].data(Qt.UserRole)["Parent Objects"]:
                if relationships_roughly_equal(old_relationship, relationship):
                    return old_relationship
        return None

    def update_tables(self):
        # get list of objects from node_tree
        self.existing_objects = self.model_controller.get_flat_tree()
        # get list of objects from objects text file
        objects_to_import: dict[str, dict] = {}
        for object in self.imported_objects:
            objects_to_import[object["Object_Name"]] = object
        # get list of objects from properties text file
        objects_required: set[str] = set()
        for property in self.imported_properties:
            objects_required.add(property["Object Name"])
        for relationship in self.imported_relationships:
            objects_required.add(relationship["Object Name"])
        # objects that exist in properties text file but neither in node_tree nor in objects text file are marked
        self.object_items = []
        for object in objects_required:
            if object in self.existing_objects:
                self.object_items.append({
                    "Status": "Existing",
                    "Object_Name": object,
                    "Object_Type": self.existing_objects[object].data(Qt.UserRole)["Object_Type"],
                    "Subfolder": "-",
                })
            elif object in objects_to_import:
                self.object_items.append({
                    "Status": "New",
                    "Object_Name": object,
                    "Object_Type": objects_to_import[object]["Object_Type"],
                    "Subfolder": get_folder(object) or "",
                })
            else:
                self.object_items.append({
                    "Status": "New",
                    "Object_Name": object,
                    "Object_Type": "",
                    "Subfolder": get_folder(object) or "",
                })
        # put objects in table
        self.objects_model = ObjectsTableModel(self.object_items)
        self.objectsTableView.setModel(self.objects_model)

        # get properties of existing objects from node_tree
        # get list of properties from properties text file
        # mark properties that conflict between node_tree and properties text file
        self.property_items = []
        for property in self.imported_properties:
            existing_property = self.find_existing_property(property)
            if existing_property is not None:
                if existing_property == property: # no conflict
                    self.property_items.append({
                        "Status": "Existing",
                        "Resolution": "Keep Old",
                        "Object Name": existing_property["Object Name"],
                        "Parent Object": existing_property["Parent Object"],
                        "Target Object": existing_property["Target Object"],
                        "Property": existing_property["Property"],
                        "Date_From": existing_property["Date_From"],
                        "Date_To": existing_property["Date_To"],
                        "Value": existing_property["Value"],
                        "Variable": existing_property["Variable"],
                        "Variable_Effect": existing_property["Variable_Effect"],
                        "Timeslice": existing_property["Timeslice"],
                        "Timeslice_Index": existing_property["Timeslice_Index"],
                        "Group_id": existing_property["Group_id"],
                        "Priority": existing_property["Priority"],
                        "Scenario": existing_property["Scenario"]
                    })
                else:
                    self.property_items.append({
                        "Status": "Conflict",
                        "Resolution": "",
                        "Object Name": property["Object Name"],
                        "Parent Object": property["Parent Object"],
                        "Target Object": property["Target Object"],
                        "Property": property["Property"],
                        "Date_From": property["Date_From"],
                        "Date_To": property["Date_To"],
                        "Value": property["Value"],
                        "Variable": property["Variable"],
                        "Variable_Effect": property["Variable_Effect"],
                        "Timeslice": property["Timeslice"],
                        "Timeslice_Index": property["Timeslice_Index"],
                        "Group_id": property["Group_id"],
                        "Priority": property["Priority"],
                        "Scenario": property["Scenario"]
                    })
            else:
                self.property_items.append({
                    "Status": "New",
                    "Resolution": "Keep New",
                    "Object Name": property["Object Name"],
                    "Parent Object": property["Parent Object"],
                    "Target Object": property["Target Object"],
                    "Property": property["Property"],
                    "Date_From": property["Date_From"],
                    "Date_To": property["Date_To"],
                    "Value": property["Value"],
                    "Variable": property["Variable"],
                    "Variable_Effect": property["Variable_Effect"],
                    "Timeslice": property["Timeslice"],
                    "Timeslice_Index": property["Timeslice_Index"],
                    "Group_id": property["Group_id"],
                    "Priority": property["Priority"],
                    "Scenario": property["Scenario"]
                })
        # add option to keep old, replace, keep both to properties with conflicts
        self.properties_model = PropertiesTableModel(self.property_items)
        self.propertiesTableView.setModel(self.properties_model)

        # get relationships of existing objects from node_tree
        # get list of relationships from relationships text file
        # mark relationships that conflict between node_tree and relationships text file
        self.relationship_items = []
        for relationship in self.imported_relationships:
            existing_relationship = self.find_existing_relationship(relationship)
            if existing_relationship is not None:
                if existing_relationship["Parent Object"] == relationship["Parent Object"] and existing_relationship["Parent Property"] == relationship["Parent Property"]: # no conflict
                    self.relationship_items.append({
                        "Status": "Existing",
                        "Resolution": "Keep Old",
                        "Object Name": relationship["Object Name"],
                        "Parent Object": relationship["Parent Object"],
                        "Parent Property": relationship["Parent Property"],
                    })
                else:
                    self.relationship_items.append({
                        "Status": "Conflict",
                        "Resolution": "",
                        "Object Name": relationship["Object Name"],
                        "Parent Object": relationship["Parent Object"],
                        "Parent Property": relationship["Parent Property"],
                    })
            else:
                self.relationship_items.append({
                    "Status": "New",
                    "Resolution": "Keep New",
                    "Object Name": relationship["Object Name"],
                    "Parent Object": relationship["Parent Object"],
                    "Parent Property": relationship["Parent Property"],
                })
        # add option to keep old, replace, keep both to relationships with conflicts
        self.relationships_model = RelationshipsTableModel(self.relationship_items)
        self.relationshipsTableView.setModel(self.relationships_model)

    def apply_changes(self) -> bool:
        for object in self.object_items:
            if object["Object_Type"] == "":
                QMessageBox.critical(self, "Error", 'One or more objects to be created are missing the "Object Type" property. Please select a type for each object and try again.')
                return False

        for property in self.property_items:
            if property["Resolution"] == "":
                QMessageBox.critical(self, "Error", 'One or more properties that conflict with existing properties are missing the "Resolution" property. Please select a resolution for each property and try again.')
                return False

        for relationship in self.relationship_items:
            if relationship["Resolution"] == "":
                QMessageBox.critical(self, "Error", 'One or more relationships that conflict with existing relationships are missing the "Resolution" property. Please select a resolution for each relationship and try again.')
                return False

        self.model_controller.pause_history = True
        self.model_controller.create_undo_snapshot()
        
        new_data = {}
        for object in self.object_items:
            new_data[object["Object_Name"]] = {
                "object": object,
                "properties": [],
                "relationships": []
            }
        for property in self.property_items:
            if property["Resolution"] == "Keep New":
                new_data[property["Object Name"]]["properties"].append(property)
        for relationship in self.relationship_items:
            if relationship["Resolution"] == "Keep New":
                new_data[relationship["Object Name"]]["relationships"].append(relationship)
        for object_name, new_object in new_data.items():
            if new_object["object"]["Status"] == "New":
                self.existing_objects[object_name] = self.model_controller.createNewObjectWithSubfolder(
                    new_object["object"]["Subfolder"],
                    object_name,
                    new_object["object"]["Object_Type"]
                )
            existing_object = self.existing_objects[object_name]
            data = copy.deepcopy(existing_object.data(Qt.UserRole))
            for new_property in new_object["properties"]:
                del new_property["Status"]
                del new_property["Resolution"]
                remove_similar_properties(data["Properties"], new_property)
                data["Properties"].append(new_property)
            for new_relationship in new_object["relationships"]:
                del new_relationship["Status"]
                del new_relationship["Resolution"]
                del new_relationship["Object Name"]
                remove_similar_relationships(data["Parent Objects"], new_relationship)
                data["Parent Objects"].append(new_relationship)
            existing_object.setData(data, Qt.UserRole)
            
        self.model_controller.create_undo_snapshot()
        self.model_controller.pause_history = False
        return True

    def accept_dialog(self, Dialog):
        if self.apply_changes():
            Dialog.accept()

class ObjectsTableView(QTableView):
    def __init__(self, parent: Optional[QWidget]):
        super().__init__(parent)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        
        self.textDelegate = TextDelegate()
        self.comboDelegate = ComboDelegate([])

        self.setItemDelegateForColumn(2, self.comboDelegate)
        self.setItemDelegateForColumn(3, self.textDelegate)

    def set_object_types(self, object_types: list[str]):
        self.comboDelegate.setItems(object_types)

class ObjectsTableModel(QAbstractTableModel):
    def __init__(self, data: List[dict]):
        super(ObjectsTableModel, self).__init__()
        self._data = data
        self.keys = ["Status", "Object_Name", "Object_Type", "Subfolder"]
        self.headers = ["Status", "Object Name", "Object Type", "Subfolder"]

    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: Qt.ItemDataRole):
        return self.dataAt(index.row(), index.column(), role)

    def dataAt(self, row: int, column: int, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            return self._data[row][self.keys[column]]

    def headerData(self, section: int, orientation: Qt.Orientation, role: int):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.headers[section]
        return super().headerData(section, orientation, role)
    
    def setData(self, index: Union[QModelIndex, QPersistentModelIndex], text: str, role: Qt.ItemDataRole):
        return self.setDataAt(index.row(), index.column(), text, role)
    
    def setDataAt(self, row: int, column: int, text: str, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            if self.keys[column] == "Object_Type":
                self._data[row]["Object_Type"] = text
            if self.keys[column] == "Subfolder":
                self._data[row]["Subfolder"] = text
            return True
        return False

    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return len(self._data)

    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return 4

    def flags(self, index: Union[QModelIndex, QPersistentModelIndex]):
        if self.keys[index.column()] in ["Object_Type", "Subfolder"] and self._data[index.row()]["Status"] == "New":
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled|Qt.ItemIsEditable
        else:
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled

class PropertiesTableView(QTableView):
    def __init__(self, parent: Optional[QWidget]):
        super().__init__(parent)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)

        self.comboDelegate = ComboDelegate(["Keep Old", "Keep New"])
        self.setItemDelegateForColumn(1, self.comboDelegate)

class PropertiesTableModel(QAbstractTableModel):
    def __init__(self, data: List[dict]):
        super(PropertiesTableModel, self).__init__()
        self._data = data
        self.keys = ["Status", "Resolution", "Object Name", "Parent Object", "Target Object", "Property", "Date_From", "Date_To", "Value", "Variable", "Variable_Effect", "Timeslice", "Timeslice_Index", "Group_id", "Priority", "Scenario"]
        self.headers = ["Status", "Resolution", "Object Name", "Parent Object", "Target Object", "Property", "Date From", "Date To", "Value", "Variable", "Variable Effect", "Timeslice", "Timeslice Index", "Group ID", "Priority", "Scenario"]

    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: Qt.ItemDataRole):
        return self.dataAt(index.row(), index.column(), role)

    def dataAt(self, row: int, column: int, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            return self._data[row][self.keys[column]]

    def headerData(self, section: int, orientation: Qt.Orientation, role: int):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.headers[section]
        return super().headerData(section, orientation, role)
    
    def setData(self, index: Union[QModelIndex, QPersistentModelIndex], text: str, role: Qt.ItemDataRole):
        return self.setDataAt(index.row(), index.column(), text, role)
    
    def setDataAt(self, row: int, column: int, text: str, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            if self.keys[column] == "Resolution":
                self._data[row]["Resolution"] = text
            return True
        return False

    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return len(self._data)

    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return 14

    def flags(self, index: Union[QModelIndex, QPersistentModelIndex]):
        if self.keys[index.column()] == "Resolution" and self._data[index.row()]["Status"] == "Conflict":
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled|Qt.ItemIsEditable
        else:
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled

class RelationshipsTableView(QTableView):
    def __init__(self, parent: Optional[QWidget]):
        super().__init__(parent)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)

        self.comboDelegate = ComboDelegate(["Keep Old", "Keep New"])
        self.setItemDelegateForColumn(1, self.comboDelegate)

class RelationshipsTableModel(QAbstractTableModel):
    def __init__(self, data: List[dict]):
        super(RelationshipsTableModel, self).__init__()
        self._data = data
        self.keys = ["Status", "Resolution", "Object Name", "Parent Object", "Parent Property"]
        self.headers = ["Status", "Resolution", "Object Name", "Parent Object", "Parent Property"]

    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: Qt.ItemDataRole):
        return self.dataAt(index.row(), index.column(), role)

    def dataAt(self, row: int, column: int, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            return self._data[row][self.keys[column]]

    def headerData(self, section: int, orientation: Qt.Orientation, role: int):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.headers[section]
        return super().headerData(section, orientation, role)
    
    def setData(self, index: Union[QModelIndex, QPersistentModelIndex], text: str, role: Qt.ItemDataRole):
        return self.setDataAt(index.row(), index.column(), text, role)
    
    def setDataAt(self, row: int, column: int, text: str, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            if self.keys[column] == "Resolution":
                self._data[row]["Resolution"] = text
            return True
        return False

    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return len(self._data)

    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return 5

    def flags(self, index: Union[QModelIndex, QPersistentModelIndex]):
        if self.keys[index.column()] == "Resolution" and self._data[index.row()]["Status"] == "Conflict":
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled|Qt.ItemIsEditable
        else:
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled