# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from typing import List, Optional, Union
from gui.core.create_json import get_folder
from gui.uis.custom.combo_delegate import ComboDelegate
from gui.uis.custom.model_controller import ModelController
from gui.uis.custom.text_delegate import TextDelegate
from qt_core import *


class Ui_ImportObjectsDialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Import Objects")
        Dialog.resize(1200, 800)
        self.verticalLayout_2 = QVBoxLayout(Dialog)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout = QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.objectsTableView = ObjectsTableView(Dialog)
        self.objectsTableView.setObjectName("objectsTableView")
        self.verticalLayout.addWidget(self.objectsTableView)
        self.addObjectsFilePushButton = QPushButton(Dialog)
        self.addObjectsFilePushButton.setObjectName("addObjectsFilePushButton")
        self.verticalLayout.addWidget(self.addObjectsFilePushButton)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.horizontalLayout.setStretch(0, 2)
        self.verticalLayout_3 = QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.propertiesTableView = PropertiesTableView(Dialog)
        self.propertiesTableView.setObjectName("propertiesTableView")
        self.verticalLayout_3.addWidget(self.propertiesTableView)
        self.addPropertiesFilePushButton = QPushButton(Dialog)
        self.addPropertiesFilePushButton.setObjectName("addPropertiesFilePushButton")
        self.verticalLayout_3.addWidget(self.addPropertiesFilePushButton)
        self.horizontalLayout.addLayout(self.verticalLayout_3)
        self.horizontalLayout.setStretch(1, 3)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.buttonBox = QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(Qt.Horizontal)
        self.buttonBox.setStandardButtons(QDialogButtonBox.Cancel|QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout_2.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QMetaObject.connectSlotsByName(Dialog)

        self.addObjectsFilePushButton.clicked.connect(self.add_objects_file)
        self.addPropertiesFilePushButton.clicked.connect(self.add_properties_file)
        self.imported_objects: list[dict] = []
        self.imported_properties: list[dict] = []

    def retranslateUi(self, Dialog):
        _translate = QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Import Objects", "Import Objects"))
        self.addObjectsFilePushButton.setText(_translate("Dialog", "Select Objects File"))
        self.addPropertiesFilePushButton.setText(_translate("Dialog", "Select Properties File"))

    def set_object_types(self, object_types: list[str]):
        self.objectsTableView.set_object_types(object_types)

    def set_model_controller(self, model_controller: ModelController):
        self.model_controller = model_controller

    def add_objects_file(self):
        (name, _) = QFileDialog.getOpenFileName(None, "Select Objects Text File")
        if name != '':
            with open(name, "r", encoding="utf8") as file_in:
                objects = []
                next(file_in)
                for line in file_in:
                    parts = line.rstrip('\n').split('\t')
                    objects.append({
                        "Object_Name": parts[0],
                        "Object_Type": parts[1],
                        "Subfolder": get_folder(parts[0]) or ""
                    })
                self.imported_objects = objects
                self.update_tables()

    def add_properties_file(self):
        (name, _) = QFileDialog.getOpenFileName(None, "Select Properties Text File")
        if name != '':
            with open(name, "r", encoding="utf8") as file_in:
                properties = []
                next(file_in)
                for line in file_in:
                    parts = line.rstrip('\n').split('\t')
                    properties.append({
                        "Object Name": parts[0],
                        "Parent Object": parts[1],
                        "Target Object": parts[2],
                        "Property": parts[3],
                        "Date_From": parts[4],
                        "Date_To": parts[5],
                        "Value": parts[6],
                        "Variable": parts[7],
                        "Variable_Effect": parts[8],
                        "Timeslice": parts[9],
                        "Timeslice_Index": parts[10],
                        "Group_id": parts[11],
                        "Priority": parts[12],
                        "Scenario": parts[13]
                    })
                self.imported_properties = properties
                self.update_tables()

    def update_tables(self):
        # get list of objects from node_tree
        existing_objects = self.model_controller.get_flat_tree()
        # get list of objects from objects text file
        objects_to_import: dict[str, dict] = {}
        for object in self.imported_objects:
            objects_to_import[object["Object_Name"]] = object
        # get list of objects from properties text file
        objects_required: set[str] = set()
        for property in self.imported_properties:
            objects_required.add(property["Object Name"])
        # objects that exist in properties text file but neither in node_tree nor in objects text file are marked
        object_items = []
        for object in objects_required:
            if object in existing_objects:
                object_items.append({
                    "Status": "Existing",
                    "Object_Name": object,
                    "Object_Type": existing_objects[object].data(Qt.UserRole)["Object_Type"],
                    "Subfolder": "-",
                })
            elif object in objects_to_import:
                object_items.append({
                    "Status": "New",
                    "Object_Name": object,
                    "Object_Type": objects_to_import[object]["Object_Type"],
                    "Subfolder": get_folder(object) or "",
                })
            else:
                object_items.append({
                    "Status": "New",
                    "Object_Name": object,
                    "Object_Type": "",
                    "Subfolder": get_folder(object) or "",
                })
        # put objects in table
        self.objects_model = ObjectsTableModel(object_items)
        self.objectsTableView.setModel(self.objects_model)

        # TODO
        # get properties of existing objects from node_tree
        # get list of properties from properties text file
        # mark properties that conflict between node_tree and properties text file
        def remove_non_unique_fields(property: dict) -> dict:
            del property["Value"]
            del property["Variable"]
            del property["Variable_Effect"]
            if "Object Name" in property:
                del property["Object Name"]
            return property

        def properties_roughly_equal(a: dict, b: dict) -> bool:
            a_copy = remove_non_unique_fields(a.copy())
            b_copy = remove_non_unique_fields(b.copy())
            return a_copy == b_copy

        def find_existing_property(property: dict) -> Optional[dict]:
            if property["Object Name"] in existing_objects:
                for old_property in existing_objects[property["Object Name"]].data(Qt.UserRole)["Properties"]:
                    if properties_roughly_equal(old_property, property):
                        return old_property
            return None
        
        property_items = []
        for property in self.imported_properties:
            existing_property = find_existing_property(property)
            if existing_property is not None:
                if existing_property == property: # no conflict
                    property_items.append({
                        "Status": "Existing",
                        "Resolution": "Keep Old",
                        "Object Name": existing_property["Object Name"],
                        "Parent Object": existing_property["Parent Object"],
                        "Target Object": existing_property["Target Object"],
                        "Property": existing_property["Property"],
                        "Date_From": existing_property["Date_From"],
                        "Date_To": existing_property["Date_To"],
                        "Value": existing_property["Value"],
                        "Variable": existing_property["Variable"],
                        "Variable_Effect": existing_property["Variable_Effect"],
                        "Timeslice": existing_property["Timeslice"],
                        "Timeslice_Index": existing_property["Timeslice_Index"],
                        "Group_id": existing_property["Group_id"],
                        "Priority": existing_property["Priority"],
                        "Scenario": existing_property["Scenario"]
                    })
                else:
                    property_items.append({
                        "Status": "Conflict",
                        "Resolution": "",
                        "Object Name": property["Object Name"],
                        "Parent Object": property["Parent Object"],
                        "Target Object": property["Target Object"],
                        "Property": property["Property"],
                        "Date_From": property["Date_From"],
                        "Date_To": property["Date_To"],
                        "Value": property["Value"],
                        "Variable": property["Variable"],
                        "Variable_Effect": property["Variable_Effect"],
                        "Timeslice": property["Timeslice"],
                        "Timeslice_Index": property["Timeslice_Index"],
                        "Group_id": property["Group_id"],
                        "Priority": property["Priority"],
                        "Scenario": property["Scenario"]
                    })
            else:
                property_items.append({
                    "Status": "New",
                    "Resolution": "Keep New",
                    "Object Name": property["Object Name"],
                    "Parent Object": property["Parent Object"],
                    "Target Object": property["Target Object"],
                    "Property": property["Property"],
                    "Date_From": property["Date_From"],
                    "Date_To": property["Date_To"],
                    "Value": property["Value"],
                    "Variable": property["Variable"],
                    "Variable_Effect": property["Variable_Effect"],
                    "Timeslice": property["Timeslice"],
                    "Timeslice_Index": property["Timeslice_Index"],
                    "Group_id": property["Group_id"],
                    "Priority": property["Priority"],
                    "Scenario": property["Scenario"]
                })
        # add option to keep old, replace, keep both to properties with conflicts
        self.properties_model = PropertiesTableModel(property_items)
        self.propertiesTableView.setModel(self.properties_model)

class ObjectsTableView(QTableView):
    def __init__(self, parent: Optional[QWidget]):
        super().__init__(parent)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        
        self.textDelegate = TextDelegate()
        self.comboDelegate = ComboDelegate([])

        self.setItemDelegateForColumn(2, self.comboDelegate)
        self.setItemDelegateForColumn(3, self.textDelegate)

    def set_object_types(self, object_types: list[str]):
        self.comboDelegate.setItems(object_types)

class ObjectsTableModel(QAbstractTableModel):
    def __init__(self, data: List[dict]):
        super(ObjectsTableModel, self).__init__()
        self._data = data
        self.keys = ["Status", "Object_Name", "Object_Type", "Subfolder"]
        self.headers = ["Status", "Object_Name", "Object_Type", "Subfolder"]

    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: Qt.ItemDataRole):
        return self.dataAt(index.row(), index.column(), role)

    def dataAt(self, row: int, column: int, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            return self._data[row][self.keys[column]]

    def headerData(self, section: int, orientation: Qt.Orientation, role: int):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.headers[section]
        return super().headerData(section, orientation, role)
    
    def setData(self, index: Union[QModelIndex, QPersistentModelIndex], text: str, role: Qt.ItemDataRole):
        return self.setDataAt(index.row(), index.column(), text, role)
    
    def setDataAt(self, row: int, column: int, text: str, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            if self.keys[column] == "Object_Type":
                self._data[row]["Object_Type"] = text
            if self.keys[column] == "Subfolder":
                self._data[row]["Subfolder"] = text
            return True
        return False

    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return len(self._data)

    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return 4

    def flags(self, index: Union[QModelIndex, QPersistentModelIndex]):
        if self.keys[index.column()] in ["Object_Type", "Subfolder"] and self._data[index.row()]["Status"] == "New":
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled|Qt.ItemIsEditable
        else:
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled

class PropertiesTableView(QTableView):
    def __init__(self, parent: Optional[QWidget]):
        super().__init__(parent)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)

        self.comboDelegate = ComboDelegate(["Keep Old", "Keep New"])
        self.setItemDelegateForColumn(1, self.comboDelegate)

class PropertiesTableModel(QAbstractTableModel):
    def __init__(self, data: List[dict]):
        super(PropertiesTableModel, self).__init__()
        self._data = data
        self.keys = ["Status", "Resolution", "Object Name", "Parent Object", "Target Object", "Property", "Date_From", "Date_To", "Value", "Variable", "Variable_Effect", "Timeslice", "Timeslice_Index", "Group_id", "Priority", "Scenario"]
        self.headers = ["Status", "Resolution", "Object Name", "Parent Object", "Target Object", "Property", "Date From", "Date To", "Value", "Variable", "Variable Effect", "Timeslice", "Timeslice Index", "Group ID", "Priority", "Scenario"]

    def data(self, index: Union[QModelIndex, QPersistentModelIndex], role: Qt.ItemDataRole):
        return self.dataAt(index.row(), index.column(), role)

    def dataAt(self, row: int, column: int, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            return self._data[row][self.keys[column]]

    def headerData(self, section: int, orientation: Qt.Orientation, role: int):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.headers[section]
        return super().headerData(section, orientation, role)
    
    def setData(self, index: Union[QModelIndex, QPersistentModelIndex], text: str, role: Qt.ItemDataRole):
        return self.setDataAt(index.row(), index.column(), text, role)
    
    def setDataAt(self, row: int, column: int, text: str, role: Qt.ItemDataRole):
        if role == Qt.DisplayRole:
            if self.keys[column] == "Resolution":
                self._data[row]["Resolution"] = text
            return True
        return False

    def rowCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return len(self._data)

    def columnCount(self, index: Union[QModelIndex, QPersistentModelIndex]):
        return 14

    def flags(self, index: Union[QModelIndex, QPersistentModelIndex]):
        if self.keys[index.column()] == "Resolution" and self._data[index.row()]["Status"] == "Conflict":
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled|Qt.ItemIsEditable
        else:
            return Qt.ItemIsSelectable|Qt.ItemIsEnabled
